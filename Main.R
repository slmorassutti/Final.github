#
#
# Main directory for Final Project
# Created by Sam Morassutti
# Feb 2020
# this project explores data visualization though heatmaps! 


# R.version.string
#"R version 3.6.2 (2019-12-12)"

# --------------libraries-----------------------------

source("https://bioconductor.org/biocLite.R")
biocLite("ComplexHeatmap")
library(ComplexHeatmap)
library(BiocManager)
#BiocManager::install("ComplexHeatmap")
library(dplyr)
# libraries needed
library(devtools)
# and the package complex heatmap 
install_github("jokergoo/ComplexHeatmap")
library(circlize)
library(cluster)



# index 
# libraries 
# setting up working directory, folders, and paths
#
#
#

#------------------------------------------------------------------------
#------------setup working directory, folders, and pathways------------------
#-----------------------------------------------------------------------
working.dir <- getwd()

# create all folders for this project so that it is organized & reproducible 
# store future file names in an object... These are base folder names
output.folder.names <- c("Clean Data", "Figures",
                         "Raw Data","Analysis","Results")

# make all folders for this project
# and make the folders if they don't exit yet.
for(i in 1:length(output.folder.names))
  if(file.exists(output.folder.names[i]) == FALSE)
    dir.create(output.folder.names[i])
#these are the pathways which are necessary to send graphs to the folders.
path.clean <- paste(working.dir, "/", output.folder.names[1], "/", sep = "")
path.figures <- paste(working.dir, "/", output.folder.names[2], "/", sep = "")
path.raw.data <- paste(working.dir, "/", output.folder.names[3], "/", sep = "")
path.analysis <- paste(working.dir, "/", output.folder.names[4], "/", sep = "")
path.results <- paste(working.dir, "/", output.folder.names[5], "/", sep = "")



# This file is the first step in my final project
# It is intended for me to familiorize myself with how to construct a heatmap
# Created by Sam Morassutti
#
#
#
# Data Visualization: An exploration of HEATMAPSSSS
# Created for presentation on Tuesday by Sam Morassutti
# this document is intended to cover the basics of building and analyizing heatmaps in R
# *** V basic! 


#-------------------------------------------------------------------------
#----------small matrix building (aka building block of heatmap)-----------------
#-----------------------------------------------------------------
# heatmaps are created from data a matrix
# similar to  vector: which is a 1D of data elements
# however, a matrix consists of a 2D array of data elements (rows and columns)
# sort of an extension
# it can only contan one atomic vector type so you can't mutiple
# variable types in the matrix
# SIDE note* you can add these to your heatmap later though
# so no stress


# to start make a small matrix! 

#------a) using rbind and cbind------------
# can also create a matrix by pasting the rows and columns together
# these functions can also be used to add a row or a column to a
# matrix that already exists (cool and handy!)
# rbind and cbind
cbind(1:6, 1:6, 1:6)
rbind(1:6, 1:6, 1:6)
# but let's use the matrix.small generated by the matrix function for the
# next steps


#------b) create small matrix-------
#using matrix function
# need a vector containing values of interest that will be in matrix
# and a dimension (at least one), so you can specify either the
# number of rows or columns
# to start, let's create a 3x4 matrix

matrix.small <- matrix(1:12, ncol = 4)
# the input length is 12, adn the number of columns are 4
# check to make sure
matrix.small
# could also use nrow and see how this changes
matrix.small <- matrix(1:12, nrow = 4)
matrix.small
# nice!
# however, for both these cases r fills in the number column by column
# to do this by row use byrow argument and set = TRUE
matrix.small <- matrix(1:12, nrow = 4, byrow = TRUE)
# check again to see how this changes
matrix.small
# this random matrix will have three groups by columns
# and three groups by rows


# so if we want to add another column to matrix.small with the values 1-4
matrix.small <- cbind(matrix.small, 1:4)
matrix.small
# great!


#------c) name rows/cols--------
# now let's get some names on these bad boys
# we have 4 columns and 4 rows
rownames(matrix.small) <- c("row1", "row2", "row3", "row4")
colnames(matrix.small) <- c("col1", "col2", "col3", "col4")
# always check 
matrix.small
# sweet
#----------------------------------------------------------------------
#------------------------------------------------------------------
#--------playing with default plots------------------------
#-------------------------------------------------------------------
#------a) base R default heatmap---------
heatmap(matrix.small)
# wooo now we see a plot with the default colours and clustering of values 
# clustering is super cool and is a VERY important part of heatmaps
# groups values based on similarity
# this has A LOT of uses
# save figure as pdf and send to figures folder
pdf(file = paste(path.figures,"Random Heatmap small.pdf", sep="/"))
heatmap(matrix.small)
dev.off()


# okay, back to this little weird small matrix heatmap
# let's get a legend on there and some titles on here
# NOW we gotta get some packages in here
# default heatmap function does not have the same capabilities as other packages
# complexheatmap is used a lot


# still having troubles wiht the packages, but we can do some of this 
#without all the right packages!


#------b) complexheatmap default settings-------
# check the default setting as it is different in this package than in base R
ComplexHeatmap::Heatmap(matrix.small)
# isn't that cute!
# are the values are positive between the input values are positive (1:12)
# default clustering has changed the order of the col/rows
# this groups values together

#add a legend title use the name = ""
ComplexHeatmap::Heatmap(matrix.small, name = "matrix.small")
# notice how the plot has been clustered based on similarity of values
# the dendrograms groups these relationships
# save as pdf and send to figures
pdf(file = paste(path.figures,"Random Heatmap small.2.pdf", sep="/"))
ComplexHeatmap::Heatmap(matrix.small, name = "matrix.small")
dev.off()


#------c) titles---------------
# to create a title 
# use the command row_title_, or column_title_
ComplexHeatmap::Heatmap(matrix.small, name = "matrix.small", 
                        row_title = "Title of rows", 
                        column_title = "Title of columns")


# save as pdf and send to figures
pdf(file = paste(path.figures,"Random Heatmap small.2.pdf", sep="/"))
ComplexHeatmap::Heatmap(matrix.small, name = "matrix.small")
dev.off()
#------d) clustering-----------------
# can also turn clustering off, do for rows and then columns
# depending on if clustering is needed or not
# let's get rid of default clustering 
# used function cluster_rows or cluster_columns = FALSE
ComplexHeatmap::Heatmap(matrix.small, name = "matrix.small", 
                        row_title = "Title of rows", 
                        column_title = "Title of columns", cluster_rows = FALSE)
# first let's remove the clustering of rows
# it's still kinda similar
# let's see what happens when we remove all clustering
ComplexHeatmap::Heatmap(matrix.small, name = "matrix.small", 
                        row_title = "Title of rows", 
                        column_title = "Title of columns", cluster_rows = FALSE, 
                        cluster_columns = FALSE)
# looks pretty different!
# save as pdf and send to figures
pdf(file = paste(path.figures,"Heatmap small.noclust.pdf", sep="/"))
ComplexHeatmap::Heatmap(matrix.small, name = "matrix.small", 
                        row_title = "Title of rows", 
                        column_title = "Title of columns", cluster_rows = FALSE, 
                        cluster_columns = FALSE)
dev.off()


#clustering can also been shown on specififcc sides of heatmap
# for example, t show clustering on the right side of rows, and 
# the bottom of the columns
# to do this use the function row_dend_side = "", column_dend_side
ComplexHeatmap:: Heatmap(matrix.small, name = "matrix.small", 
                         row_title = "Title of rows", 
                         column_title = "Title of columns",
                         row_dend_side = "right", 
                         column_dend_side = "bottom")
# save as pdf and send to figures
pdf(file = paste(path.figures,"Heatmap small clust on sides.pdf", sep="/"))
ComplexHeatmap:: Heatmap(matrix.small, name = "matrix.small", 
                         row_title = "Title of rows", 
                         column_title = "Title of columns",
                         row_dend_side = "right", 
                         column_dend_side = "bottom")
dev.off()

#------e) change the colours---------
# let's play around with some colours!
# going to use colorRamp2 to do this
# if matrix is continuous, provide a vector of colours 
# the colours will be interpolated linearly
# however, mapping isn't robust against outliers
# becasue it starts with the min and max values
# in the matrix

# therefore, if you set the colour to the max/min
# of the matrix, it will be identical to the
# default plot

# let's change some colours!!!
# create a function and call is col_fun
# input the range of values (we already know these becasue we created them)
# but can also get quickly by the min and max commands
min(matrix.small) #1
max(matrix.small) #12

# because our range is from 1-12, we can select three colours and assign them 
# to the min, mid, max 
col_fun = colorRamp2(c(1, 6, 12), c("mediumvioletred", "white", "mediumspringgreen"))
# now we can input the sequence (how many values in our colour range)
col.fun <- col_fun(seq(1, 12))
ComplexHeatmap::Heatmap(matrix.small, name = "matrix.small", col = col.fun, 
                        row_title = "Title of rows", 
                        column_title = "Title of columns")

# see how this plot show the spread in values much better than the default colours
# the legend is much nicer 
# the clustering also creates groups 

# save as pdf and send to figures
pdf(file = paste(path.figures,"Heatmap small new col.1.pdf", sep="/"))
ComplexHeatmap::Heatmap(matrix.small, name = "matrix.small", col = col.fun, 
                        row_title = "Title of rows", 
                        column_title = "Title of columns")
dev.off()

# however, it is common practice to assign darker colours the larger values 
# so if we switch these colours it should represent this little matrix better


# let's repeat the above however change the order of colours
col_fun = colorRamp2(c(1, 6, 12), c("mediumspringgreen", "white", "mediumvioletred"))
# now we can input the sequence (how many values in our colour range)
col.fun <- col_fun(seq(1, 12))
ComplexHeatmap::Heatmap(matrix.small, name = "matrix.small", col = col.fun, 
                        row_title = "Title of rows", 
                        column_title = "Title of columns")


#cool! let's save it and compare it to the previous
pdf(file = paste(path.figures,"Heatmap small new col.2.pdf", sep="/"))
ComplexHeatmap::Heatmap(matrix.small, name = "matrix.small", col = col.fun, 
                        row_title = "Title of rows", 
                        column_title = "Title of columns")
dev.off()

#----------------------------------------------------------------------------
#----- Larger random matrix (aka mat)---------------
#----------------------------------------------------------------------------
#------a) create matrix (mat)-----
# his random matrix will have three groups by columns
# and three groups by rows

# use the fucntion set.seed to generate random numbers
?set.seed

set.seed(123)
nr1 = 4; nr2 = 8; nr3 = 6; nr = nr1 + nr2 + nr3
nc1 = 6; nc2 = 8; nc3 = 10; nc = nc1 + nc2 + nc3 

# now let's combine all of the rows and columns in a matrix 
# set the mean and sd 
# let's call the matrix object mat!
mat = cbind(rbind(matrix(rnorm(nr1 * nc1, mean = 1, sd = 0.5), nr = nr1),
                  matrix(rnorm(nr2 * nc1, mean = 0, sd = 0.5), nr = nr2),
                  matrix(rnorm(nr3 * nc1, mean = 0, sd = 0.5), nr = nr3)),
            rbind(matrix(rnorm(nr1 * nc2, mean = 0, sd = 0.5), nr = nr1),
                  matrix(rnorm(nr2 * nc2, mean = 1, sd = 0.5), nr = nr2),
                  matrix(rnorm(nr3 * nc2, mean = 0, sd = 0.5), nr = nr3)),
            rbind(matrix(rnorm(nr1 * nc3, mean = 0.5, sd = 0.5), nr = nr1),
                  matrix(rnorm(nr2 * nc3, mean = 0.5, sd = 0.5), nr = nr2),
                  matrix(rnorm(nr3 * nc3, mean = 1, sd = 0.5), nr = nr3)))
# Now let's shuffle the rows and columns randomly 
mat = mat[sample(nr, nr), sample(nc, nc)] 
rownames(mat) = paste0("row", seq_len(nr))
colnames(mat) = paste0("column", seq_len(nc))
str(mat)
# check the class in order to confirm that this is a matrix!
class(mat)
# Great! Now we have a random data matrix called mat
# that has 24 columns and 18 rows
mat
# woah those are some interesting numbers
# let's check the range by using the min and max function
min(mat) # -1.154584
max(mat) # 2.62052

#------b) visualize mat------------
# Now let's visualize this random data and create a heatmap with default settings
# yayayayayayay
# to get the lendeng and legend name
# use function name = "", then put the name of legend wooooo
ComplexHeatmap::Heatmap(mat, name = "mat")
# save as pdf and send to figures folder!
pdf(file = paste(path.figures,"Default Random Heatmap.pdf", sep="/"))
ComplexHeatmap::Heatmap(mat, name = "mat")
dev.off()



#------c) play with colours----------
# colours are a very important component of representation of data in the matrix
# colour mapping functions
#allow you to create a fucntion in which a vector of values will result
# in the correspond colours

# If using heatmap(), always use the circlcolorRam2() in order to make a color
# mapping function
# there are two arguements in the colorRamp2
# a vector of break values and their corresponding colors 


# create a color scheme that corresponds to the set values with a rang of -2 to 2
# in this map, the colors aren't affected by outliers
# the color mapping function is robost to outliers

col_fun = colorRamp2(c(-2, 0, 2), c("mediumspringgreen", "white", "mediumvioletred"))
col.fun <- col_fun(seq(-3, 3))
ComplexHeatmap::Heatmap(mat, name = "mat", col = col.fun)
# the negative values are mediumvioletred and the positive are mediumspringgreen

# save as pdf and send to figures folder!
pdf(file = paste(path.figures,"Random Heatmap2.pdf", sep="/"))
ComplexHeatmap::Heatmap(mat, name = "mat", col = col.fun)
dev.off()

# let's do the same thing but make the middle value equal black for more contrast
col_fun = colorRamp2(c(-2, 0, 2), c("mediumspringgreen", "black", "mediumvioletred"))
col.fun.2 <- col_fun(seq(-3, 3))
ComplexHeatmap::Heatmap(mat, name = "mat", col = col.fun.2)
# the negative values are mediumvioletred and the positive are mediumspringgreen

# save as pdf and send to figures folder!
pdf(file = paste(path.figures,"Random Heatmap.black.1.pdf", sep="/"))
ComplexHeatmap::Heatmap(mat, name = "mat", col = col.fun.2)
dev.off()

# can also create a rainbow color scheme 
ComplexHeatmap::Heatmap(mat, name = "mat", col = rev(rainbow(10)))
# save as pdf and send to figures folder!
pdf(file = paste(path.figures,"Random Heatmap3.pdf", sep="/"))
ComplexHeatmap::Heatmap(mat, name = "mat", col = rev(rainbow(10)))
dev.off()

# if matrix is continuous, provide a vector of colours 
# the colours will be interpolated linearly
# however, mapping isn't robust against outliers
# becasue it starts with the min and max values
# in the matrix

# therefore, if you set the colour to the max/min
# of the matrix, it will be identical to the
# default plot


# can also have colours for a discrete numeric matrix
# and also for character matrix
# default clustering will be applied in the dsicrete plot
# and can be in character plots too if set 



# -----d) inspect NA values ---------------
# NA is able to be in matrix
# but you can set the colour so it is identifiable
# the default colour is grey (how do I put this in legend)
# to change the colour use argument
# na_col


# let's try by making the na values black
ComplexHeatmap::Heatmap(mat, name = "mat", na_col = "black")
# it appears that there are no na values.....
# the plot is back to default colour scheme

#------e) create border-------------
# create border by using the border true fucntion
ComplexHeatmap::Heatmap(mat, name = "mat", border = TRUE)
pdf(file = paste(path.figures,"Random Heatmap4 border.pdf", sep="/"))
ComplexHeatmap::Heatmap(mat, name = "mat", border = TRUE)
dev.off()


#------f) title plots-----------------
# titles are important as they describe what the plot is of 
# can be set by column and or row
# add titles in the complexheatmap package
# so the funciton column_titles should work for the top.... 
# and the function 
# graphic paramaters can be set by the function gpar
?gpar()
# it is used by get.gpar()

# use the command row_title_gp, or column_title_gp
ComplexHeatmap::Heatmap(mat, name = "mat", col = col.fun.2, row_title = "Title of rows", 
        column_title = "Title of columns")
# save as pdf and send to figures folder
pdf(file = paste(path.figures,"Random Heatmap titles.1.pdf", sep="/"))
ComplexHeatmap::Heatmap(mat, name = "mat", col = col.fun.2, row_title = "Title of rows", 
                        column_title = "Title of columns")
dev.off()

# now let's give the columns and rows a title and specify the fontsize and type
# let's use fontsize 15 and bold
# use the column_title_gp = gpar() function to specify 
ComplexHeatmap::Heatmap(mat, name = "mat", col = col.fun.2, 
                        column_title = "column title", 
                        column_title_gp = gpar(fontsize = 15, fontface = "bold"), 
                        row_title = "row title", 
                        row_title_gp = gpar(fontsize = 15, fontface = "bold"))

pdf(file = paste(path.figures,"Random Heatmap titles.2.pdf", sep="/"))
ComplexHeatmap::Heatmap(mat, name = "mat", col = col.fun.2, 
                        column_title = "column title", 
                        column_title_gp = gpar(fontsize = 15, fontface = "bold"), 
                        row_title = "row title", 
                        row_title_gp = gpar(fontsize = 15, fontface = "bold"))
dev.off()

# let's so the same thing again however with the col.fun colour scheme instead 
# this will allow for a comparison of the plots
ComplexHeatmap::Heatmap(mat, name = "mat", col = col.fun, 
                        column_title = "column title", 
                        column_title_gp = gpar(fontsize = 15, fontface = "bold"), 
                        row_title = "row title", 
                        row_title_gp = gpar(fontsize = 15, fontface = "bold"))

pdf(file = paste(path.figures,"Random Heatmap titles.white.3.pdf", sep="/"))
ComplexHeatmap::Heatmap(mat, name = "mat", col = col.fun, 
                        column_title = "column title", 
                        column_title_gp = gpar(fontsize = 15, fontface = "bold"), 
                        row_title = "row title", 
                        row_title_gp = gpar(fontsize = 15, fontface = "bold"))
dev.off()
#------g) clustering-------------
# maybe the most important aspect/function of heatmap visulaization
# there are many clustering methods
# two default: euclidean, and pearson both with pre-determined distance methods 
# hclust, dengrodgram (object or class) that can be/ or already are clustered


# can also turn clustering off, do for rows and then columns
# depending on if clustering is needed or not
ComplexHeatmap::Heatmap(mat, name = "mat", cluster_rows = FALSE)
# save and send to figures!
pdf(file = paste(path.figures,"Random Heatmap cluster.1.pdf", sep="/"))
ComplexHeatmap::Heatmap(mat, name = "mat", cluster_rows = FALSE)
dev.off()

ComplexHeatmap::Heatmap(mat, name = "mat", cluster_columns = FALSE)
# so odd looking!
# save and send to figures
pdf(file = paste(path.figures,"Random Heatmap cluster.2.pdf", sep="/"))
ComplexHeatmap::Heatmap(mat, name = "mat", cluster_columns = FALSE)
dev.off()


# to show clustering on specififcc sides
# for example, show clustering on the right side of rows, and 
# the bottom of the columns
ComplexHeatmap:: Heatmap(mat, name = "mat", row_dend_side = "right", 
                         column_dend_side = "bottom")
# save figure and send to folder!
pdf(file = paste(path.figures,"Random Heatmap cluster.3.pdf", sep="/"))
ComplexHeatmap:: Heatmap(mat, name = "mat", row_dend_side = "right", 
                         column_dend_side = "bottom")
dev.off()



#--------------------------------------------------------------
#---------------Apply to real data set------------------------
#-------------------------------------------------------------
#--------a) import, save, and process---------------------------------
# expression data set from OncoPrint
# read in data for lung adenocarcinoma
# this data set is in complexheatmap so we can read it in directory from here

mat = read.table(system.file("extdata", package = "ComplexHeatmap", 
                             "tcga_lung_adenocarcinoma_provisional_ras_raf_mek_jnk_signalling.txt"), 
                 header = TRUE, stringsAsFactors = FALSE, sep = "\t")
# save as a csv and send to raw data folder
write.csv(mat,paste(path.clean,"lung_adenocarcinoma_ras_raf_mek_jnk_signalling.csv",sep="/"))
# can also import the now saved csv to see the raw data 
View(lung_adenocarcinoma_ras_raf_mek_jnk_signalling)
# we can see just from the csv that there are 26 genes
# can notice the different types of mutations MUT, AMP, HOMDEL, MUT;AMP, NA

#--------b) look at structure-----

dim(mat) # for dimensions
nrow(mat) # for number of rows 
ncol(mat) # for number of col

#------- c) create funny plot with data frame----
# now, just to see what happens, let's create a plot with the imported data
# as this is always the first step in an analysis
# with default complexheatmap settings... only specify legend name "mat"
# right away we get a warning that this is a dtaa frame and it must be converted
ComplexHeatmap:: Heatmap(mat, name = "mat")
# this is not plotting now.... but before it created a hilarious graph...

# woah it is different this time... that is kinda awesome
# the default plot show the case ID on the left side of the plot with colours 
# coressponding to the samples in the huge legend that doesn;t fit on the page 
# well, that is a bit ugly... what is going on with the labels 
# let's save it for now though becasue it's so odd
pdf(file = paste(path.figures,"lung.oddness.pdf", sep="/"))
ComplexHeatmap:: Heatmap(mat, name = "mat")
dev.off()


#--------d) process and transform data frame to matrix---------------
# Now we need to duoble check to see if indeed out data is not a matrix
class(mat) 
# this is a data frame
# we know that we cannot use the heatmap function on a data frame...
# so we need to transform this data into a matrix


head(mat)
# we can see that the genes are formated across the colummns, and samples
# are located in the first column
# we want to do a few things to this data set to change this
# it needs to be a matrix
# we need to flip the axis and re order where the genes and samples are within 
# the matrix

# okay let's do it! 
mat[is.na(mat)] = ""
# look at row names and process the data set 
# the following section is make the formating the data so that it will plot 
# in the desired fashion
# the goal is to the genes lined up on the left side of the matrix 
# and the samples organzied column wise across the plot

rownames(mat) = mat[, 1]
mat = mat[, -1]
mat=  mat[, -ncol(mat)]
mat = t(as.matrix(mat))
mat[1:3, 1:3]
str(mat)
#check class to see if this transformation worked
class(mat) 
# nice it is a matrix


#--------e) create heatmap!-------
# now let's plot it again and see if it works 
# hopefully the error messages/warning will not show up now that it is a matix
ComplexHeatmap::Heatmap(mat, name = "mat")

# interesting
# so now the genes are are the right of the plot
# the samples on on the bottom 
# this is quite different than the first plot before the data was processed 
# there is a lot going on here 
# save as pdf
pdf(file = paste(path.figures,"lung,matrix.1.pdf", sep="/"))
ComplexHeatmap:: Heatmap(mat, name = "mat")
dev.off()

# let's add some row and column titles
# note: I don't know why this plot is different every time you run the code
ComplexHeatmap::Heatmap(mat, name = "mat", 
                        column_title = "Lung adenocarcinoma Samples", 
                        column_title_gp = gpar(fontsize = 15, fontface = "bold"), 
                        row_title = "Genes", 
                        row_title_gp = gpar(fontsize = 15, fontface = "bold"))

# save weird plot! and discuss it
pdf(file = paste(path.figures,"lung.matrix.2.pdf", sep="/"))
ComplexHeatmap::Heatmap(mat, name = "mat", 
                        column_title = "Lung adenocarcinoma Samples", 
                        column_title_gp = gpar(fontsize = 15, fontface = "bold"), 
                        row_title = "Genes", 
                        row_title_gp = gpar(fontsize = 15, fontface = "bold"))
dev.off()
#--------f) set mutation as colours----------------------------------------

# let's move on to: identifying mutations with colours
# now that we know there are different mutation types/alterations
# the complex heatmap example only focused on the MUT, AMP, and HOMDEL


# let's give each one a colour so that it can be identified 
col = c("HOMDEL" = "blue", "AMP" = "red", "MUT" = "#008000")
alter_fun = list(
  background = function(x, y, w, h) {
    grid::grid.rect()(x, y, w-unit(0.5, "mm"), h-unit(0.5, "mm"), 
              gp = gpar(fill = "#CCCCCC", col = NA))
  },
  # big blue
  HOMDEL = function(x, y, w, h) {
    grid::grid.rect(x, y, w-unit(0.5, "mm"), h-unit(0.5, "mm"), 
              gp = gpar(fill = col["HOMDEL"], col = NA))
  },
  # bug red
  AMP = function(x, y, w, h) {
    grid::grid.rect()(x, y, w-unit(0.5, "mm"), h-unit(0.5, "mm"), 
              gp = gpar(fill = col["AMP"], col = NA))
  },
  # small green
  MUT = function(x, y, w, h) {
    grid::grid.rect()(x, y, w-unit(0.5, "mm"), h*0.33, 
              gp = gpar(fill = col["MUT"], col = NA))
  }
)
# check to see if alterations are set to correct color 
col
# okay it seems to be all good yay
# can it be translated into a plot though????


# SAD! so from here on this is proving to be very tricky
# plotting anything with the method provided in the complexheatmap
# package is only results in a lot of errors
# the rest of this code can be found in the "troubled" folder
# -------g) run into trouble-------------------------
